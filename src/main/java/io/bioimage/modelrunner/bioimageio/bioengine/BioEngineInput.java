package io.bioimage.modelrunner.bioimageio.bioengine;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.Buffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.GZIPOutputStream;

import org.msgpack.jackson.dataformat.MessagePackFactory;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.bioimage.modelrunner.bioimageio.description.weights.ModelWeight;
import io.bioimage.modelrunner.tensor.Tensor;

/**
 * Class to create inputs that can be sent to the BioEngine server.
 * The input tensors should be defined as an array of inputs, where
 * each of the inputs can be either a String, int or any other type,
 * but in case the input is an array, it should be encoded as a 
 * {@link HashMap}. It needs to have the key "_rtype" with the
 * corresponding value "ndarray", the key "_rvalue" with an array of
 * bytes corresponding to the data wanted to be encoded, a key "_rshape"
 * which should contain the shape of the array and finally the "_rdtype"
 * corresponding to the array datatype.
 * The array of inputs should be then included in another hashmap under
 * the key "inputs", together with the key "model_name" and the name of
 * the model and "decode_json" true.
 * There is an example defined in Python at: 
 * https://gist.github.com/oeway/b6a6b810f94c91bb902e80a2f788b9e2#file-access_triton_service_hyhpa-py-L22
 * 
 * @author Carlos Javier García López de Haro
 */
public class BioEngineInput {
	/**
	 * Name of the model that is going to be called
	 */
	private String modelName;
	/**
	 * Map containing the instances needed to provide an input to the 
	 * server.
	 * The input needs to have:
	 *  -An entry called "inputs", whose value is another Map that contains
	 *   the info about the input tensors
	 *  -An entry called model_name with the name of the model
	 *  -A fixed entry called decoe_json that equals to true
	 */
	private HashMap<String, Object> kwargs = new HashMap<String, Object>();
	/**
	 * List containing encoded tensors that are going to be used by the BioEngine.
	 * The entries of this list can be either:
	 *  -A @see java.util.LinkedHashMap generated by 
	 *   @see org.bioimageanalysis.icy.deepicy.model.bioimageio.BioEngineInputTensor
	 *   for array tensors
	 *  -A @see java.util.LinkedHashMap for non dimensional parameters
	 */
	private List<Object> inputs = new ArrayList<Object>();
	/**
	 * Models available in the BioImage.io have a model_id to identify them
	 */
	private String bioimageioModelId;
	/**
	 * String key corresponding to the model name parameter in the 
	 * {@link #kwargs} map
	 */
	private static String modelNameKey = "model_name";
	/**
	 * String key corresponding to the actual tensor inputs in the 
	 * {@link #kwargs} map
	 */
	private static String inputsKey = "inputs";
	/**
	 * String key corresponding to the decode Json parameter in the 
	 * {@link #kwargs} map
	 */
	private static String decodeJsonKey = "decode_json";
	/**
	 * Value corresponding to the decode Json parameter in the 
	 * {@link #kwargs} map. It is fixed.
	 */
	private static boolean decodeJsonVal = true;
	/**
	 * Key for the input of the BioEngine corresponding to the type of serialization
	 */
	private static String serializationKey = "serialization";
	/**
	 * Value for the BioEngine serialization
	 */
	private static String serializationVal = "imjoy";
	/**
	 * Key for the Bioimage.io model_id as in the rdf.yaml
	 */
	private static String modelIDKey = "model_id";
	/**
	 * Optional key to run a Bioimage.io model to specify in which weights
	 * the model is going to run
	 */
	private static String modelWeightsKey = "weight_format";
	/**
	 * Optional key to run a Bioimage.io model to specify in which weights
	 * the model is going to run
	 */
	private static String rdfKey = "return_rdf";
	/**
	 * OPtional weights selected. If no weights are proposed the default weights
	 * are selected
	 */
	private String modelWeights;
	/**
	 * Whether the inputs have been closed or not
	 */
	private boolean closed = false;
	
	/**
	 * Create the Bioengine input 
	 * @param modelName
	 * 	name of the model that is going to be called
	 */
	private BioEngineInput(String modelName, String modelID) {
		this.modelName = modelName;
		bioimageioModelId = modelID;
		workaroundModelID();
		kwargs.put(modelNameKey, modelName);
		if (BioEngineServer.isBioImageIoKey(modelName)) {
			kwargs.put(serializationKey, serializationVal);
		} else {
			kwargs.put(decodeJsonKey, decodeJsonVal);
		}
	}
	
	/** TODO 
	 * Workaround for BioImage.io model runner. It does not work with the full version, it
	 * only works with: major_version_/second_version
	 */
	private void workaroundModelID() {
		if (bioimageioModelId == null)
			return;
		int nSubversions = bioimageioModelId.length() - bioimageioModelId.replace("/", "").length();
		if (nSubversions == 2) {
			bioimageioModelId = bioimageioModelId.substring(0, bioimageioModelId.lastIndexOf("/"));
		}
	}
	
	/**
	 * Build the object that contains the inputs to
	 * the BioEngine in the corresponding format
	 * @param modelName
	 * 	the name of the model of interest
	 * @return an object that can be used to provide
	 * 	inputs to the BioEngine
	 */
	public static BioEngineInput buildNonBioimageioInput(String modelName) {
		return new BioEngineInput(modelName, null);
	}
	
	/**
	 * Build the object that contains the inputs to
	 * the BioEngine in the corresponding format
	 * @param modelName
	 * 	the name of the model of interest
	 * @return an object that can be used to provide
	 * 	inputs to the BioEngine
	 */
	public static BioEngineInput buildBioimageioInput(String modelName) {
		return new BioEngineInput(BioEngineServer.bioImageIoModelName(), modelName);
	}
	
	/**
	 * Build the object that contains the inputs to
	 * the BioEngine in the corresponding format
	 * @param modelName
	 * 	the name of the model of interest
	 * @param modelId
	 * 	the model_id of the model of interest as of in the rdf.yaml. Must be always null
	 * 	unless the wanted model comes from the bioimage.io repo. In that case modelName 
	 * 	always has to be "bioengine-model-runner"
	 * @return an object that can be used to provide
	 * 	inputs to the BioEngine
	 */
	public static BioEngineInput build(String modelName, String modelId) {
		if (modelId != null && !BioEngineServer.isBioImageIoKey(modelName)) {
			throw new IllegalArgumentException("A non null second parameter (model_id) should "
					+ "only be provided in the case a model available in the BioImage.io "
					+ "is going to be run. In that case, the first parameter (modelName) must "
					+ "always be: " + BioEngineServer.bioImageIoModelName());
		}
		return new BioEngineInput(modelName, modelId);
	}
	
	/**
	 * MEthod to be called when no more inputs need to be defined
	 */
	public void setAllInputs() {
    	throwExceptionIfClosed();
		if (bioimageioModelId != null) {
			Map<String, Object> auxMap = new HashMap<String, Object>();
			auxMap.put(inputsKey, inputs);
			auxMap.put(modelIDKey, bioimageioModelId);
			auxMap.put(modelIDKey, bioimageioModelId);
			auxMap.put(rdfKey, true);
			if (modelWeights != null)
				auxMap.put(modelWeightsKey, modelWeights);
			ArrayList<Object> auxList = new ArrayList<Object>();
			auxList.add(auxMap);
			kwargs.put(inputsKey, auxList);
		} else {
			kwargs.put(inputsKey, inputs);
		}
	}
	
	/**
	 * Adds the sequence as an input to the model. Call {@link #setAllInputs()}
	 * when there are no more inputs to define.
	 * @param seq
	 * 	the sequence we want as an input
	 * @param axesOrder
	 * 	the shape of the array of interest
	 * @throws Exception if the data type of the sequence is not within the allowed ones 
	 */
	public void addArrayInput(Sequence seq, String axesOrder) throws Exception {
    	throwExceptionIfClosed();
		int[] arrAxesOrder = Tensor.convertToTensorDimOrder(axesOrder);
		int[] seqSize = SequenceUtils.getSequenceSizeArray(seq);
		int [] shapeAxesOrder = PatchGridCalculator.arrayToWantedAxesOrderAddOnes(seqSize, "xyczb", axesOrder);
		addArrayInput(sequence2buffer(seq, arrAxesOrder), shapeAxesOrder);
	}
	
	/**
	 * Adds the buffer as an input to the model
	 * @param buff
	 * 	the buffer we want as an input
	 * @param axesOrder
	 * 	the shape of the array of interest
	 * @throws Exception if the data type of the buffer is not within the allowed ones 
	 */
	public void addArrayInput(Buffer buff, int[] axesOrder) throws Exception {
    	throwExceptionIfClosed();
		inputs.add(BioEngineInputTensor.build(buff, axesOrder));
	}
	
	/**
	 * MEthod to set the weight format selected in the bioengine run
	 * @param ww
	 * 	seleced weight format, has to be one of the allowed weight formats
	 */
	public void setWeights(String ww) {
		modelWeights = ww.toLowerCase();
		if (!modelWeights.equals(ModelWeight.getKerasID()) && !modelWeights.equals(ModelWeight.getOnnxID())
				&& !modelWeights.equals(ModelWeight.getPytorchID()) && !modelWeights.equals(ModelWeight.getTensorflowID())
				&& !modelWeights.equals(ModelWeight.getTensorflowJsID())
				&& !modelWeights.equals(ModelWeight.getTorchscriptID())) {
			throw new IllegalArgumentException("The selected weight format (" + ww + ") "
					+ "does not correspond with any of the weight formats available: "
					+ ModelWeight.getKerasID() + ", " + ModelWeight.getTorchscriptID() + ", " + ModelWeight.getPytorchID()
					 + ", " + ModelWeight.getTensorflowID() + ", " + ModelWeight.getTensorflowJsID()
					 + ", " + ModelWeight.getOnnxID());
		}
	}
	
	public static Buffer sequence2buffer(Sequence seq, int[] shape) {
		return TensorBuilder.build(seq, shape);
	}
	
	/**
	 * Adds the Object as a parameter input to the model.
	 * In this case there is no need to encode it.
	 * Arrays or objects with more than one value (images)
	 * should not be provided as inputs in this way. Call {@link #setAllInputs()}
	 * when there are no more inputs to define.
	 * @param paramKey
	 * 	the name of the input single dimension tensor
	 * @param param
	 * 	the value of the input single dimension tensor
	 */
	public void addParameterInput(String paramKey, Object param) {
    	throwExceptionIfClosed();
		Map<String, Object> pp = new HashMap<String, Object>();
		pp.put(paramKey, param);
		inputs.add(pp);
	}
	
	/**
	 * Serialize the {@link LinkedHashMap} and compress it to be
	 * able to feed it to the BioEngine
	 * @return the serialized and compressed input to the
	 * 	BioEngine ready to be sent
	 * @throws JsonProcessingException if the inputs could not be
	 * 	serialized
	 * @throws IOException if the serialized inputs could not be compressed
	 */
	public byte[] serializeAndCompress() throws JsonProcessingException, IOException {
    	throwExceptionIfClosed();
		return compress(serialize());
	}
	
	/**
	 * Compresses an array of bytes into an smaller array of bytes
	 * @param serialized
	 * 	the original array of bytes
	 * @return the compressed array of bytes
	 * @throws IOException if the bytes could not be compressed
	 */
	public static byte[] compress(byte[] uncompressedData) throws IOException {
		byte[] result = new byte[]{};
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream(uncompressedData.length);
             GZIPOutputStream gzipOS = new GZIPOutputStream(bos)) {
            gzipOS.write(uncompressedData);
            // You need to close it before using bos
            gzipOS.close();
            result = bos.toByteArray();
            bos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return result;
	}
	
	/**
	 * Serialize the {@link LinkedHashMap}
	 * @return the serialized input map
	 * @throws JsonProcessingException  if there is an error with the
	 * serialization
	 */
	public byte[] serialize() throws JsonProcessingException {
    	throwExceptionIfClosed();
		ObjectMapper objectMapper = new ObjectMapper(new MessagePackFactory());
		byte[] bytes = objectMapper.writeValueAsBytes(this.kwargs);
		return bytes;
	}

	/**
	 * Get the model name
	 * @return the modelName
	 */
	public String getModelName() {
    	throwExceptionIfClosed();
		return modelName;
	}

	/**
	 * Free from the memory the creaated bioengine inputs
	 */
	public void close() {
		modelName = null;
		inputs = null;
		kwargs = null;
		bioimageioModelId = null;
		closed = true;
	}
    
    /**
     * Whether the tensor is closed or not
     * @return true if closed, false otherwise
     */
    public boolean isClosed() {
    	return closed;
    }
    
    /**
     * Throw {@link IllegalStateException} if the tensor has been closed
     */
    private void throwExceptionIfClosed() {
    	if (!closed)
    		return;
    	throw new IllegalStateException("The tensor that is trying to be modified has already been "
    			+ "closed.");
    }
}
